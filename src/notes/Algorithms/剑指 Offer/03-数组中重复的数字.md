## 数组中重复的数字
找出数组中重复的数字。


在一个长度为 `n` 的数组 `nums` 里的所有数字都在 `0～n-1` 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**
```
输入：
[2, 3, 1, 0, 2, 5, 3]

输出：2 或 3 
```

### 方法一：哈希表 / Set
由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。

#### 复杂度分析：
- 时间复杂度 $O(n)$：遍历数组一遍。使用集合 `(Set)`，添加元素的时间复杂度为 $O(1)$，故总的时间复杂度是 $O(n)$   
- 空间复杂度 $O(n)$：不重复的每个元素都可能存入集合，因此占用 $O(n)$ 额外空间

#### 代码：
```JavaScript
var findRepeatNumber = function(nums) {
    let set = new Set()
    for(let i = 0; i < nums.length; i++) {
        if (set.has(nums[i])) return nums[i]
        set.add(nums[i])
    }
    return -1
};
```

### 方法二： 利用一个萝卜一个坑的特性
题目说明尚未被充分使用，即 `在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内`  
如果不存在重复数字，只可能是 $[0, 1, 2, ..., n-1]$ 这种情况  

#### 算法流程：
1. 遍历数组 $nums$，设索引初始值为 $i = 0$
   1. 若 $nums[i] = i$：说明此数字已在对应索引位置，无需交换，因此跳过；
   2. 若 $nums[nums[i]] = nums[i]$：代表索引 $nums[i]$ 处和索引 $i$ 处的元素值都为 $nums[i]$，即找到一组重复值，返回此值；
   3. 否则： 交换索引为 $i$ 和 $nums[i]$ 的元素值，将此数字交换至对应索引位置。
2. 若遍历完毕尚未返回，则返回 $-1$。

#### 复杂度分析：
- 时间复杂度 $O(n)$：遍历数组一遍
- 空间复杂度 $O(1)$：只需要一个额外的标记交换数组元素

#### 代码：
```JavaScript
var findRepeatNumber = function(nums) {
  for (let i = 0; i < nums.length; i++) {
      while (nums[i] !== i) {
          if (nums[i] === nums[nums[i]]) return nums[i]
          // 注意 顺序 && 分号
          ;[nums[nums[i]], nums[i]] = [nums[i], nums[nums[i]]]
      }
  }
  return -1
};
```
