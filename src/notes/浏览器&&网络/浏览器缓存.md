## 浏览器缓存
浏览器缓存是浏览器第一次向一个服务器发起HTTP请求后，服务器会返回请求的资源，之后浏览器再向该服务器请求资源就可以视情况使用强缓存和协商缓存

### 1、强缓存
浏览器不会向服务器发送请求，直接从缓存中读取资源，返回 `200` 状态码，并且 `Size` 显示 `from disk cache` 或 `from memory cache`。  

**强缓存可以通过设置 两种 HTTP Header 实现**

1. Expires  
Expires是Web服务器 `响应头` 字段，用来指定资源到期的时间，是 `服务器端` 的具体时间点。`Expires: Wed, 22 Oct 2018 08:41:00`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。  
弊端：客服端 和 服务端 时间不同步

2. Cache-Control  
Cache-Control这个字段是 `http 1.1` 的规范，一般常用该字段的 `max-age` 值来进行判断，它是一个相对时间，比如 `Cache-Control:max-age=3600` 代表资源的有效期是 `3600 秒`。并且响应头中的 `Date` 表示消息发送的时间，表示当前资源在 `Date ~ Date +3600s` 这段时间里都是有效的。  
Cache-Control 可以在 `请求头` 或者 `响应头` 中可 `组合设置`。  

    在 `请求头` 中可选的值有：  
    | 字段名称 | 说明 |
    | :-: | :-:  |
    | max-age=delta-seconds | 告知服务器希望接收一个存在时间(Age)不大于delta-seconds秒的资源 |
    | no-cache | 告知(代理)服务器不使用 强缓存 |
    | min-fresh=delta-seconds | 告知(代理)服务器客户端希望接一个在小于delta-seconds秒内被更新过的资源 |

    在 `响应头` 中可选的值有： 
    | 字段名称 | 说明 |
    | :-: | :-:  |
    | max-age=delta-seconds | 告诉客户端，该资源在delta-seconds秒内是新鲜的，无需向服务器发请求 |
    | no-cache | 告知客服端，不使用 强缓存 |
    | public | 所有内容都将被缓存（客户端和代理服务器都可缓存） |
    | private | 所有内容只有客户端可以缓存 |

**两者对比**
- Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires  
- 在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法  

强缓存判断是否缓存的依据来自于是否超出某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略
### 2、协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程  

**主要有以下两种情况：**  
1. 协商缓存生效，返回304和Not Modified
![协商缓存生效](/src/images/cache-control_304.webp '协商缓存生效')

1. 协商缓存失效，返回200和请求结果   
![协商缓存失效](/src/images/cache-control_200.webp '协商缓存失效')

**协商缓存可以通过设置两种 HTTP Header 实现**  

1. Last-Modified 和 If-Modified-Since  
    浏览器在第一次访问资源时，服务器返回资源的同时，在 `响应头` 中添加 `Last-Modified`，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；
    ```
    Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
    ```
    浏览器下一次请求这个资源，浏览器检测到有 `Last-Modified`，于是添加 `If-Modified-Since` 请求头，值就是 `Last-Modified` 中的值；  
    服务器再次收到这个资源请求，会根据 `If-Modified-Since` 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 `304` 和 `空的响应体`，直接从缓存读取，如果 `If-Modified-Since` 的时间不等于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 `200`

    但是 `Last-Modified` 存在一些弊端：  
   - 如果本地打开缓存文件，即使没有对文件内容进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
   - 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源  

    既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match

2. ETag 和 If-None-Match  
    `Etag` 是服务器响应请求时，返回当前资源文件的一个唯一标识，只要资源有变化，`Etag` 就会重新生成。  
    浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 `Etag` 值放到 request header 里的 `If-None-Match` 里，服务器只需要比较客户端传来的 `If-None-Match` 跟自己服务器上该资源的 `ETag` 是否一致，就能很好地判断资源相对客户端而言是否被修改  
   - 如果服务器发现 `ETag` 匹配不上，那么直接会返回 `200` 和新的资源（也包括了新的ETag）
   - 如果 `ETag` 是一致的，则直接返回 `304` 告知客户端直接使用本地缓存

**两者对比**
- 精确度：`Etag` 要优于 `Last-Modified` 
- 性能：`Etag` 要逊于 `Last-Modified`，`Last-Modified` 只需要记录时间，而 `Etag` 需要服务器通过算法来计算出一个hash值
- 优先级：`Etag` 大于 `Last-Modified`

### 缓存机制
强缓存优先于协商缓存进行，若强缓存生效则直接使用缓存，若不生效则进行协商缓存。协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。  
具体流程图如下：  
![缓存机制](/src/images/cached_strategy.webp '缓存机制')

test
test2