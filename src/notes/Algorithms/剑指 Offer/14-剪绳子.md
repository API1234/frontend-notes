## 剪绳子
给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段`（m、n都是整数，n > 1 && m >= 1）`，每段绳子的长度记为 `k[0], k[1]...k[m - 1]`。请问 `k[0] * k[1] * ... * k[m - 1]` 可能的最大乘积是多少？

 
```
示例:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

注意：本题与主站 [343 题](https://leetcode-cn.com/problems/integer-break/) 相同

### 方法一：动态规划
对于的正整数 $n$，当 $n \ge 2$ 时，可以拆分成至少两个正整数的和。令 $k$ 是拆分出的第一个正整数，则剩下的部分是 $n-k$，$n−k$ 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

创建数组 $\textit{dp}$，其中 $\textit{dp}[i]$ 表示将正整数 $i$ 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，$0$ 不是正整数，$1$ 是最小的正整数，$0$ 和 $1$ 都不能拆分，因此 $\textit{dp}[0]=\textit{dp}[1]=0$。

当 $i \ge 2$ 时，假设对正整数 $i$ 拆分出的第一个正整数是 $j（1 \le j < i）$，则有以下两种方案：

- 将 $i$ 拆分成 $j$ 和 $i−j$ 的和，且 $i−j$ 不再拆分成多个正整数，此时的乘积是 $j \times (i-j)$

- 将 $i$ 拆分成 $j$ 和 $i−j$ 的和，且 $i−j$ 继续拆分成多个正整数，此时的乘积是 $j \times \textit{dp}[i-j]$


因此，当 $j$ 固定时，有 $\textit{dp}[i]=\max(j \times (i-j), j \times \textit{dp}[i-j])$。由于 $j$ 的取值范围是 $1$ 到 $i−1$，需要遍历所有的 $j$ 得到 $\textit{dp}[i]$ 的最大值，因此可以得到状态转移方程如下：

$$
\textit{dp}[i]=\mathop{\max}\limits_{1 \le j < i}\{\max(j \times (i-j), j \times \textit{dp}[i-j])\}
$$


最终得到 $\textit{dp}[n]$ 的值即为将正整数 $n$ 拆分成至少两个正整数的和之后，这些正整数的最大乘积。
#### 复杂度分析：
- 时间复杂度 $O(n^2)$：其中 $n$ 是给定的正整数。对于从 $2$ 到 $n$ 的每一个整数都要计算对应的 $dp$ 值，计算一个整数对应的 $dp$ 值需要 $O(n)$ 的时间复杂度，因此总时间复杂度是 $O(n^2)$
- 空间复杂度 $O(n)$：其中 $n$ 是给定的正整数。创建一个数组 $dp$，其长度为 $n+1$

#### 代码
```JavaScript
var cuttingRope = function(n) {
  const dp = new Array(n + 1)
  dp[0] = dp[1] = 0

  for (let i = 2; i <= n; i++) {
    let curMax = 0
    for (let j = 1; j < i; j++) {
      curMax = Math.max(curMax, j * (i - j), j * dp[i - j])
    }
    dp[i] = curMax
  }

  return dp[n]
};
```