## TCP协议
### 一、TCP报文格式
![TCP报文格式](../../images/tcp_header.png)

**首部字段**  

- `源端口` 和 `目的端口` 各占2个字节，分别写入源端口号和目的端口号
- `序号` 占4字节，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号
- `确认号` 占4字节，是期望收到对方下一个报文段的第一个数据字节的序号
- `数据偏移` 占 `4bit`，指出 TCP 报文段的首部长度
- `保留` 占 `6bit`，保留为今后使用，目前应置为0
- 6个 `控制位` 占 `6bit`
  1. `URG`：紧急标志
  2. `ACK`：确认标志
  3. `PSH`：推送标志
  4. `RST`：复位标志
  5. `SYN`：同步标志
  6. `FIN`：结束标志
- `窗口` 占2字节，用来表示想收到的每个TCP数据段的大小
- `检验和` 占2字节，源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的
- `紧急指针` 占2字节，仅在 `URG = 1` 时才有意义，它指出本报文段中的紧急数据的字节数
- `选项 和 填充` 长度可变，最长可达40字节

### 二、TCP三次握手
![TCP三次握手](../../images/tcp_connect.jpg)
#### 第一次握手
起初两端都处于 `CLOSED` 关闭状态  
Client 将标志位 `SYN` 置为1，随机产生一个值 `seq = x`，并将该数据包发送给 Server  
Client 进入 `SYN-SENT` 请求连接状态，等待Server确认
#### 第二次握手
Server 收到数据包后由标志位 `SYN = 1`得知 Client 请求建立连接  
Server 将标志位 `SYN` 和 `ACK` 都置为1，`ack = x + 1`，随机产生一个值 `seq = y`，并将该数据包发送给 Client 以确认连接请求  
Server 进入 `SYN-RCVD` 同步收到状态，此时操作系统为该 TCP 连接分配 `TCP缓存` 和 `变量`
#### 第三次握手
Client 收到确认后，检查 `ack` 是否为 `x + 1`，`ACK`是否为1，如果正确则将标志位 `ACK` 置为1，`ack = y + 1`，并且此时操作系统为该TCP连接分配 `TCP缓存` 和 `变量`，并将该数据包发送给 Server  
Server 检查 `ack` 是否为 `y + 1`，`ACK` 是否为1，如果正确则连接建立成功  
Client 和 Server 进入 `ESTABLISHED`连接成功状态

### 三、TCP四次挥手
![TCP四次挥手](../../images/tcp_disconnect.jpg)
#### 第一次挥手
Clien 发送一个 `FIN`，用来关闭 Client 到 Server 的数据传送  
Client进入 `FIN_WAIT_1` 状态  
这时候 Client 同时也变成了 `half-close(半关闭)` 状态，即无法向服务端发送报文，只能接收
#### 第二次挥手
Server 收到 `FIN` 后，发送一个 `ACK` 给 Client，Server 进入 `CLOSE_WAIT` 状态  
客户端接收到了服务端的确认，变成了 `FIN-WAIT2` 状态
#### 第三次挥手
Server 发送一个 `FIN`，用来关闭 Server 到 Client 的数据传送，Server 进入 `LAST_ACK` 状态
#### 第四次挥手
Client 收到 `FIN` 后，Client 进入 `TIME_WAIT` 状态，发送`ACK` 给 Server  
Client 需要等待 2 个 `MSL(Maximum Segment Lifetime，报文最大生存时间)`，在这段时间内如果 Client 没有收到服务端的重发请求，那么表示 `ACK` 成功到达，挥手结束，否则 Client 重发 `ACK`  
Server 收到后进入 `CLOSED` 状态，完成四次握手

### 三、常见问题
#### 问题一：TCP和UDP的区别
TCP是一个 `面向连接的`、`可靠的`、`基于字节流`的传输层协议

UDP是一个`面向无连接`的传输层协议

**和 UDP 相比，TCP 有三大核心特性:**

1. **面向连接**：所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程

2. **可靠性**：TCP 可靠性体现在 `有状态`、`可控制`。相应的，UDP 就是`无状态`、`不可控`
   - 有状态：TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错
   - 可控制：当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发  

3. **面向字节流**：UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流

#### 问题二：为什么建立连接需要三次握手，而断开连接需要四次握手
因为 Server 在接收到 `FIN`, 往往不会立即返回 `FIN`, 必须等到 Server 所有的报文都发送完毕了，才能发 `FIN`。因此先发一个 `ACK` 表示已经收到客户端的 `FIN`，延迟一段时间才发 `FIN`。这就造成了四次挥手。

#### 问题三：等待 2MSL 的意义
**如果不等待会怎样？**

如果不等待，Client 直接 `CLOSED`，当 Server 还有很多数据包要给 Client 发，且还在路上的时候，若 Client 的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱

**那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?**

- 1 个 `MSL` 确保主动关闭方最后的 `ACK` 报文最终能达到对端
- 1 个 `MSL` 确保对端没有收到 `ACK` 重传的 `FIN` 报文可以到达
#### 问题四：SYN Flood 攻击
三次握手前，服务端的状态从 `CLOSED` 变为 `LISTEN`, 同时在内部创建了两个队列：`半连接(SYN)队列` 和 `全连接(ACCEPT)队列`

##### 半连接队列
当 Client 发送 `SYN` 到 Server，Server 收到以后回复 `ACK` 和 `SYN`，状态由 `LISTEN` 变为 `SYN_RCVD`，此时这个连接就被推入了 `SYN队列`
##### 全连接队列
当 Client 返回 `ACK` , Server 接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入 `ACCEPT队列`
##### SYN Flood 攻击原理
`SYN Flood` 属于典型的 `DoS/DDoS` 攻击。其攻击的原理就是用Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 疯狂发送 `SYN`。对于服务端而言，会产生两个危险的后果:
- 处理大量的 `SYN` 包并返回对应 `ACK`, 势必有大量连接处于 `SYN_RCVD` 状态，从而占满整个半连接队列，无法处理正常的请求
- 由于是不存在的 IP，Server 长时间收不到客户端的 `ACK`，会导致服务端不断重发数据，直到耗尽 Server 的资源
##### 如何应对 SYN Flood 攻击
1. 增加 `SYN` 连接，也就是增加半连接队列的容量
2. 减少 `SYN + ACK` 重试次数，避免大量的超时重发
3. 利用 `SYN Cookie` 技术，在服务端接收到 `SYN` 后不立即分配连接资源，而是根据这个 `SYN` 计算出一个 `Cookie`，连同第二次握手回复给客户端，在客户端回复 `ACK` 的时候带上这个 `Cookie` 值，服务端验证 `Cookie` 合法之后才分配连接资源